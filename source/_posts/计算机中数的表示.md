# 计算机中数的表示

## 无符号数与有符号数

### 1.	原码

- **整数原码**定义
    $$
    [x]_原 = \left\{
      \begin{array}{lr}
        0,x     &:& 2^n & >&   x &\geq& 0\\
        2^x-x   &:& 0   &\geq& x &>&   -2^n
      \end{array}
    \right.
    $$
    式中，x为**真值**，n为**整数的位数**

eg:

​	$$x = + 1110$$时，$$[x]_原 = 0,1110$$

​	$$x = -1110$$时，$$[x]_原 = 2^4 - (-1110) = 1,1110$$

- **小数原码**定义
    $$
    [x]_原 = \left\{
      \begin{array}{lr}
       x    &:&   1 &>&     x  &\geq& 0\\
       1-x  &:&   0 &\geq&  x  &>&    -1
      \end{array}
    \right.
    $$
    
    式中x为**真值**

eg:

​	$x = 0.1101$时，$[x]_原 = 0.1101$

​	$x = -0.1101$时，$[x]_原 = 1 - (-0.1101) = 1.1101$

由上可知，已知**真值**可以求**原码**，反过来可由**原码**求得**真值**。

eg：

​	当$[x]_原 = 1.0011$时，由定义可得
$$
x = 1 - [x]_原 = 1-1.0011 = -0.0011
$$
​	当$[x]_原 = 1,1100$时，由定义得，
$$
x = 2^n - [x]_原 = 2^4(10000) - 1,1100 = -1100
$$
​	当$[x]_原 = 0.1101$时，$x = 0.1101$

​	当$x = 0$时，
$$
\begin{aligned}\\ 
    [+0.0000]_原 &= 0.0000\\
    [-0.0000]_原 &= 1-(0.0000) = 1.0000
\end{aligned}
$$

​	可见，$[+0]_原$不等于$[-0]_原$,即**原码中的“零”有两种表示形式**

- 缺点

    使用原码进行加减时，符号不同，需要先判断两数的绝对值大小，然后将绝对值大的数减去绝对值小的数，符号位以绝对值大的为准。而如果使用一个等价于整数来代替这个负数，则可以用加法来代替减法，实际上计算机只能实现加法，此时，采用**补码**这满足此设想。

### 2.补码

$$
-3 \equiv  +9  \quad (mod 12)
$$

表示对模12来说，-3和+9是互为补数的。因此确定了“模”，就可以找到一个与负数等价的正数(该正数即为负数的补数)来代替负数，这样就可以把减法变为加法。

- 模
    	- 一个负数可用它的正补数来代替，而这个正补数可以用模加上负数本身求得。
    - 一个正数和一个负数互为补数时，他们绝对值之和即为模数。
    - 正数的补数即该正数本身。

- **整数补码**定义
    $$
    [x]_补 = \left\{
      \begin{array}\\
        0,x        &: &2^n& > &x&\geq &0&\\
        2^{n+1}+x  &: &0& \geq &x&> &-2^n& \quad (mod 2^{n+1})
      \end{array}
    \right.
    $$
    式中，x为**真值**，n为**整数位数**

    

eg:

​	当$x = +1010$时，$[x]_补 = 0,1010$

​	当$x = -1101$时，$[x]_补 = 2^{n+1} + x = 10000-1101 = 1,0011$

- **小数补码**定义：

$$
[x]_补 = \left\{
  \begin{array}\\
    x        &: &1& > &x&\geq &0&\\
    2+x      &: &0& \geq &x&> &-1& \quad (mod 2)
  \end{array}
\right.
$$

​	式中，x为**真值**

eg：

​	当$x = 0.1001$时，$[x]_补 = 0.1001$，

​	当$x = -0.0110$时，$[x]_补 = 2 + x = 10.0000 - 0.0110 = 1.1010 $

​	当$x = 0$时，
$$
\begin{aligned}\\
    [+0.0000]_补 &= 0.0000 \\
    [-0.0000]_补 &= 2 + (-0.0000) = 10.0000 - 0.0000 = 0.0000
\end{aligned}
$$
 	可见,$[+0]_补 = [-0]_补 = 0.0000$，即**补码中的“零”只有一中表示形式**。

​	对于小数，若$x = -1$，则根据小数补码定义，有$[x]_补 = 2 +x = 10.0000 - 1.0000 = 1.0000$。可见，$-1$本不属于小数范围，但却有$[-1]_补$存在，则是因为补码中的“零”只能有一种表示形式，故它比原码多表示一个“-1”，

由上可知，已知**真值**可求**补码**，反过来可由**补码**求得**真值**

eg：

​	若$[x]_补 = 1.0101$,则
$$
x = [x]_补 - 2 = 1.0101 - 10.0000 = -0.1011
$$
​	若$[x]_补 = 1,1110$则
$$
x = [x]_补 - 2^{4+1} = 1,1110 - 100000 = -0010
$$
​	若$[x]_补 = 0.1101$则
$$
 x = [x]_补 = 0.1101
$$
同理，当模数为4时，形成了双符号位的补码，如$x = -0.1001$对$(mod \quad 2^2)$而言
$$
[x]_补 = 2^2 +x = 100.0000 - 0.1001 = 11.0111
$$
此时，这种双符号位的补码又叫做**变形补码**，在**阶码运算**和**溢出运算**总有特殊作用。

虽然，引入补码的概念是为了消除减法运算，但是根据补码的定义，形成补码的过程中，仍出现了减法，

eg：
$$
\begin{aligned}\\
	x &=-1011\\
    [x]_补&=2^{4+1} +x = 100000 - 1011 = 1,0101\\
          &=11111 + 00001 + x \quad &*&\because x为负数,使用减法表示\\
          &=11111 + 00001 - x\\
          &=(11111-x) \ + 00001 \quad	&*&括号中相当于进行取反操作 
\end{aligned}
$$
这样就可以认为对**原码**求**补码**,可以认为是**原码除符号位外，每位求反，末尾加一**

反过来由**补码**求**原码**，**减一取反**则为原码，当然符号为不参与。

### 3.	反码

在上文补码的求取过程中，提到过取反，取反后的结果就是**反码**。所以反码通常用来由原码求补码或者由补码求原码的中间过渡。

- **整数反码**定义
$$
  [x]_反 = \left\{
      \begin{array}\\
          0,x            &:& 2^n &>& x    &\geq& 0\\
          (2^{n+1}-1)+x  &:& x   &\geq& x &>& -2^n \quad (mod(2^{n+1}-1))
      \end{array}
  \right.
$$
  式中，x为**真值**，n为**整数的位数**

eg：

​	$x = +1101$时，$[x]_反 = 0,1101$

​	$x = -1101$时，$[x]_反 = (x^{4+1}-1) + x = 11111 - 1101 = 1,0010$

- **小数反码**定义
    $$
    [x]_反 = \left\{
    	\begin{array}\\
    		x                 &:& 1 &>& x &\geq& 0\\
    		(2 - 2^{-n}) + x  &:& 0 &\geq& x &>& -1 \quad (mod(2-2^{-n}))
    	\end{array}
    \right.
    $$
    式中，x为**真值**，n为小数的**位数**。

eg：

​	$x =\ + 0.0110$时，$[x]_反 = 0.0110$.

​	$x =\ -0.0110$时，$[x]_反 = (2-2^-4) + x = (10.0000 - 0.0001) - 0.0110 = 1.1111-0.0110 = 1.1001$

 	$x = 0$时，
$$
\begin{aligned}\\
	[+0.0000]_反 &= 0.0000 \\
	[-0.0000]_反 &= (10.0000 - 0.0001) - 0.0000 = 1.1111 
\end{aligned}
$$
可见，$[+0]_补$不等于$[-0]_补$，即**反码中的“零”有两种表示形式**。

实际上反码也可以看作$mod(2- 2^{-n})$(对于小数)或$mod(2^{n+1}-1)$(对于整数)的补码。与补码相比，仅在末尾差一，因此有些书上称**小数的补码**为**2的补码，小数的反码**为**1的补码**。

### 4.	移码

用补码表示时，符号位与数值位一起编码，很难从补码沙上直接判断真值的大小，因此产生了**移码**

- **移码**的定义

$$
[x]_移 = 2^n + x \qquad (2^n > x \geq -2^n)
$$

式中，x为**真值**，n为**整数的位数**

eg:

​	$x = 10100$，$[x]_移 = 2^5 +10100 = 100000 + 10100 = 1,10100$

​	$x = -10100$，$[x]_移 =2^5 - 10100 = 0,01100$

​	$x = 0$时
$$
\begin{array}\\
	[+0]_移 &= 2^5 + 0 &= 1,00000\\
    [-0]_移 &= 2^5 - 0 &= 1,00000
\end{array}
$$
可见$[+0]_移$等于$[-0]_移$，即**移码表示中的“零”是唯一的**。

**同一个真值的<u>移码</u>与<u>补码</u>仅差一个符号位**，若将**补码**的符号位由“0”变为“1”（正数），或由“1”变为“0”（负数），即可得到该**真值**的**移码**。

 ## 数的定点表示和浮点表示



